import os
import tkinter as tk
from tkinter import messagebox
import subprocess
import platform
import re
from datetime import datetime
from collections import Counter
import string

SAVE_FOLDER = "autosaved_notes"
SAVE_FILE = "dumpedit_notes.txt"
BACKUP_COUNT = 5

os.makedirs(SAVE_FOLDER, exist_ok=True)
FULL_PATH = os.path.join(SAVE_FOLDER, SAVE_FILE)

class SmartFileNamer:
    """Handles intelligent file naming based on content analysis"""
    
    # Common words to ignore when generating names
    STOP_WORDS = {
        'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 
        'of', 'with', 'by', 'from', 'up', 'about', 'into', 'through', 'during',
        'before', 'after', 'above', 'below', 'over', 'under', 'again', 'further',
        'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all',
        'any', 'both', 'each', 'few', 'more', 'most', 'other', 'some', 'such',
        'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than', 'too', 'very',
        'can', 'will', 'just', 'should', 'now', 'i', 'me', 'my', 'myself', 'we',
        'our', 'ours', 'ourselves', 'you', 'your', 'yours', 'yourself', 'he',
        'him', 'his', 'himself', 'she', 'her', 'hers', 'herself', 'it', 'its',
        'itself', 'they', 'them', 'their', 'theirs', 'themselves', 'what',
        'which', 'who', 'whom', 'this', 'that', 'these', 'those', 'am', 'is',
        'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had',
        'having', 'do', 'does', 'did', 'doing', 'would', 'could', 'should'
    }
    
    @staticmethod
    def generate_filename(content, max_length=50):
        """Generate a meaningful filename from text content"""
        if not content or not content.strip():
            return f"empty_note_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # Try different strategies in order of preference
        strategies = [
            SmartFileNamer._extract_title_line,
            SmartFileNamer._extract_first_sentence,
            SmartFileNamer._extract_keywords,
            SmartFileNamer._extract_first_words
        ]
        
        for strategy in strategies:
            filename = strategy(content, max_length)
            if filename:
                return SmartFileNamer._sanitize_filename(filename)
        
        # Fallback
        return f"note_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    
    @staticmethod
    def _extract_title_line(content, max_length):
        """Extract potential title from first line if it looks like a title"""
        lines = content.strip().split('\n')
        if not lines:
            return None
            
        first_line = lines[0].strip()
        
        # Check if first line looks like a title
        if (len(first_line) < 100 and  # Not too long
            not first_line.endswith('.') and  # Doesn't end with period
            len(first_line.split()) <= 10 and  # Not too many words
            first_line.strip()):  # Not empty
            
            # Extra points if it's followed by empty line or different formatting
            if len(lines) > 1 and (lines[1].strip() == '' or 
                                 lines[1].startswith('=') or 
                                 lines[1].startswith('-')):
                return first_line[:max_length]
            
            # Or if it's short and looks title-like
            if len(first_line) < 50:
                return first_line[:max_length]
        
        return None
    
    @staticmethod
    def _extract_first_sentence(content, max_length):
        """Extract first sentence if it's a reasonable length"""
        # Find first sentence
        sentences = re.split(r'[.!?]+', content.strip())
        if sentences:
            first_sentence = sentences[0].strip()
            if 10 <= len(first_sentence) <= 80:  # Reasonable length
                return first_sentence[:max_length]
        return None
    
    @staticmethod
    def _extract_keywords(content, max_length):
        """Extract important keywords from content"""
        # Clean and split text
        words = re.findall(r'\b[a-zA-Z]{3,}\b', content.lower())
        
        # Remove stop words
        filtered_words = [w for w in words if w not in SmartFileNamer.STOP_WORDS]
        
        if not filtered_words:
            return None
        
        # Get most common words
        word_counts = Counter(filtered_words)
        top_words = [word for word, count in word_counts.most_common(4)]
        
        # Create filename from top words
        filename = '_'.join(top_words)
        return filename[:max_length] if filename else None
    
    @staticmethod
    def _extract_first_words(content, max_length):
        """Fallback: use first few meaningful words"""
        words = re.findall(r'\b[a-zA-Z]{3,}\b', content)
        if words:
            # Take first 3-5 words, skip stop words
            meaningful_words = []
            for word in words[:10]:  # Look at first 10 words
                if word.lower() not in SmartFileNamer.STOP_WORDS:
                    meaningful_words.append(word)
                if len(meaningful_words) >= 4:
                    break
            
            if meaningful_words:
                filename = '_'.join(meaningful_words)
                return filename[:max_length]
        
        return None
    
    @staticmethod
    def _sanitize_filename(filename):
        """Clean filename for filesystem compatibility"""
        # Remove invalid characters
        filename = re.sub(r'[<>:"/\\|?*]', '', filename)
        
        # Replace spaces and special chars with underscores
        filename = re.sub(r'[^\w\-_.]', '_', filename)
        
        # Remove multiple underscores
        filename = re.sub(r'_+', '_', filename)
        
        # Remove leading/trailing underscores
        filename = filename.strip('_')
        
        # Ensure it's not empty
        if not filename:
            filename = f"note_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        return filename

class DumpEdit:
    def __init__(self, root):
        self.root = root
        self.root.title("DumpEdit")
        self.current_filename = None  # Track current file name

        self.text = tk.Text(root, wrap=tk.WORD)
        self.text.pack(expand=True, fill=tk.BOTH)

        # Buttons
        btn_frame = tk.Frame(root)
        btn_frame.pack(fill=tk.X)

        self.undo_btn = tk.Button(btn_frame, text="Undo", command=self.undo)
        self.undo_btn.pack(side=tk.LEFT)

        self.redo_btn = tk.Button(btn_frame, text="Redo", command=self.redo)
        self.redo_btn.pack(side=tk.LEFT)

        self.clear_btn = tk.Button(btn_frame, text="Clear", command=self.clear_screen)
        self.clear_btn.pack(side=tk.LEFT)

        # New button for saving with smart name
        self.save_named_btn = tk.Button(btn_frame, text="Save As Smart Name", 
                                       command=self.save_with_smart_name)
        self.save_named_btn.pack(side=tk.LEFT)

        self.open_folder_btn = tk.Button(btn_frame, text="Open Folder", command=self.open_folder)
        self.open_folder_btn.pack(side=tk.RIGHT)

        # State
        self.backups = []
        self.current_index = -1

        # Load file if exists
        self.load_file()

        # Events
        self.text.bind("<KeyRelease>", self.on_key)
        self.text.bind("<Control-a>", self.select_all)
        self.text.bind("<Button-3>", self.show_right_click_menu)

        self.right_click_menu = tk.Menu(self.root, tearoff=0)
        self.right_click_menu.add_command(label="Cut", command=lambda: self.text.event_generate("<<Cut>>"))
        self.right_click_menu.add_command(label="Copy", command=lambda: self.text.event_generate("<<Copy>>"))
        self.right_click_menu.add_command(label="Paste", command=lambda: self.text.event_generate("<<Paste>>"))
        self.right_click_menu.add_command(label="Select All", command=self.select_all)
        self.right_click_menu.add_separator()
        self.right_click_menu.add_command(label="Save with Smart Name", command=self.save_with_smart_name)

    def on_key(self, _event=None):
        content = self.text.get("1.0", tk.END).strip()
        if not content:
            return
        self.add_backup(content)
        self.save_file(content)

    def load_file(self):
        if os.path.exists(FULL_PATH):
            with open(FULL_PATH, "r", encoding="utf-8") as f:
                content = f.read()
                self.text.insert("1.0", content)
                self.backups.append(content)
                self.current_index = 0

    def add_backup(self, content):
        if self.backups and self.backups[-1] == content:
            return
        if len(self.backups) >= BACKUP_COUNT:
            self.backups.pop(0)
        self.backups.append(content)
        self.current_index = len(self.backups) - 1

    def save_file(self, content):
        with open(FULL_PATH, "w", encoding="utf-8") as f:
            f.write(content)

    def save_with_smart_name(self):
        """Save current content with an intelligently generated filename"""
        content = self.text.get("1.0", tk.END).strip()
        
        if not content:
            messagebox.showwarning("Empty Content", "Cannot save empty content with smart name.")
            return
        
        # Generate smart filename
        base_name = SmartFileNamer.generate_filename(content)
        
        # Add timestamp to avoid conflicts
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{base_name}_{timestamp}.txt"
        
        # Ensure uniqueness
        full_path = os.path.join(SAVE_FOLDER, filename)
        counter = 1
        while os.path.exists(full_path):
            name_parts = filename.rsplit('.', 1)
            if len(name_parts) == 2:
                filename = f"{name_parts[0]}_{counter}.{name_parts[1]}"
            else:
                filename = f"{filename}_{counter}"
            full_path = os.path.join(SAVE_FOLDER, filename)
            counter += 1
        
        try:
            with open(full_path, "w", encoding="utf-8") as f:
                f.write(content)
            
            self.current_filename = filename
            messagebox.showinfo("Saved", f"Content saved as:\n{filename}")
            
            # Update window title to show current file
            self.root.title(f"DumpEdit - {filename}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save file: {str(e)}")

    def undo(self):
        if self.current_index > 0:
            self.current_index -= 1
            self.load_backup()

    def redo(self):
        if self.current_index < len(self.backups) - 1:
            self.current_index += 1
            self.load_backup()

    def load_backup(self):
        content = self.backups[self.current_index]
        self.text.delete("1.0", tk.END)
        self.text.insert("1.0", content)
        self.save_file(content)

    def clear_screen(self):
        if messagebox.askyesno("Clear Screen", "Are you sure you want to clear everything?"):
            current = self.text.get("1.0", tk.END).strip()
            self.add_backup(current)
            self.text.delete("1.0", tk.END)
            self.on_key()  # Trigger autosave
            self.root.title("DumpEdit")  # Reset title
            self.current_filename = None

    def select_all(self, _event=None):
        self.text.tag_add("sel", "1.0", "end")
        return "break"

    def show_right_click_menu(self, event):
        try:
            self.right_click_menu.tk_popup(event.x_root, event.y_root)
        finally:
            self.right_click_menu.grab_release()
            self.right_click_menu.unpost()

    def open_folder(self):
        if platform.system() == "Windows":
            os.startfile(SAVE_FOLDER)
        elif platform.system() == "Darwin":  # macOS
            subprocess.Popen(["open", SAVE_FOLDER])
        else:  # Linux and others
            subprocess.Popen(["xdg-open", SAVE_FOLDER])

if __name__ == "__main__":
    root = tk.Tk()
    app = DumpEdit(root)
    root.mainloop()